[TOC]


<style>
  img {
    width: 80%; /* 统一宽度（百分比或固定值如600px） */
    height: auto; /* 保持比例 */
    display: block; /* 居中显示 */
    margin: 0 auto;
  }
</style>



# :scroll: 4.23 HBM 讲座

## :star2: HBM 技术
面向人工智能的芯片

### :dizzy: Motivation
DDR 的速度每 3-5 年翻一倍

- 3DS DDR 替代了传统的 DDR 设计
- Wide IO 替代 LPDDR
- **HBM** 替代了 GDDR 

### :dizzy: Introduction of HBM

- 变化 : 
  - 可堆叠更多芯片（容量+）
  - 可分离更多通道（性能+）
  - 可集成更多电池（容量+）
  - 可降低电源电压（功率效率+）
- 制约摆放 HBM3 数量的因素是 logic die 的长边长度, 这里 H100 一边放了 3 个

### :dizzy: Future products
- 行业趋势1 : 集成更多(边缘)HBM堆叠
- 行业趋势2 : 异质三维集成
- 行业趋势3 : Processing in Memory (PIM)
___

# :scroll: 4.28 & 4.30 总线及总线标准

## :star2: 1. 总线
在多于两个模块(设备或子系统)之间传送信息的公共通路
- 组成
  - 传输信息的电路
  - 管理信息传输的协议
- 分类
  - **片上总线** : 中央处理器芯片内部的总线
  - **内总线** : 系统总线或版级总线, 各插件板之间信息传输的通路
  - **外总线** : 通信总线, 计算机系统之间/计算机系统与其他系统

### :dizzy: 总线模块

#### :dash: 总线主模块 (Bus Master)

-   具有**总线控制**能力，在获得总线控制权之后**能启动总线传输**（读数据或写数据）
-   示例 : CPU、DMA 控制器

#### :dash: 总线从模块 (Bus Slave)

-   能够对总线传输**作出响应**（接收写数据、返回读数据、返回“错误”响应等），但本身不具备总线控制能力
-   示例 : 存储器

### :dizzy: 辅助元件

**总线译码器(Bus Decoder)**  : 根据当前控制总线的主模块提供的地址，选择作为本次总线传输目标的从模块

**总线仲裁器(Bus Arbiter)**  : 在总线上有**多个主模块同时请求**使用总线时，决定由哪个主模块获得总线控制权, 让总线得到合理、高效地使用

![bus_sys](11总线与总线标准.assets/bus_sys.png)

地址总线 : 主模块 → 总线 → 从模块
数据/控制总线 : 主模块 ↔ 总线 ↔ 从模块

![bus_circuit](11总线与总线标准.assets/bus_circuit.png)

![bus_80386](11总线与总线标准.assets/bus_80386.png)

![bus_complex_sys](11总线与总线标准.assets/bus_complex_sys.png)

- 真实系统中的很多总线模块包含主模块和从模块的双重功能及接口
- 有比较慢的设备，使用总线桥接器来连接。

## :star2: 2. 常见总线协议

**事实标准** : 计算机系统厂家所采用的一种总线，由于其性能优越，逐渐形成一种被业界广泛支持和承认的事实总线标准

**国际标准** : 在国际标准组织或机构主持下开发和制定的总线标准，公布后由厂家和用户使用

### :dizzy: 总线标准的内容

1. **机械特性** : 规定模块插件的机械尺寸，总线插头、插座的规格及位置等

2. **电气特性** : 规定总线信号的逻辑电平、噪声容限及负载能力等

3. **功能特性** : 给出各总线信号的名称及功能定义

4. **规程特性** : 对各总线信号的动作过程及时序关系进行说明

- 举例 : ISA、PCI、PCI Express、EISA、AGP、USB

- 现在最常用的是 **PCIe**

> PPT里此处有 ISA, EISA, PCA, AGP 的历史, 感觉不会考

### :dizzy: PCI Express

#### :dash: 全新的基础架构

-   **串行方式**传输数据，依靠高频率获得高性能
-   **全双工运作模式**，同时进行数据发送和接收
-   点对点连接结构，而非传统的共享结构

#### :dash: PCIe 总线物理层采用差分信号传输

- 优点 : 抗干扰能力强, 能有效抑制电磁干扰, 时序定位准确
- 缺点 : 在电路板上，差分信号一定要走两根等长、等宽、紧密靠近且在同一层面的线，布线难度高

#### :dash: PCIe链路的带宽和编码方式
- PCIe使用GT(Gigatransfer)计算链路的峰值带宽
$$单条链路的峰值带宽 = 总线频率×数据位宽×2 (单位 : GT/s）$$
- PCIe链路可以由多个 **通道（Lane）** 组成, 目前支持宽度 为 1, 2, 4, 8, 12, 16 和 32 的链路
## :star2: 3. 总线协议实例

### :dizzy: 场景 1 : 读写 1 个数据

![time_1a](11总线与总线标准.assets/time_1a.png)

![time_1b](11总线与总线标准.assets/time_1b.png)  


> 这张图中的灰色六边形代表此时信号不稳定。
>
> A 代表此时信号已经稳定，32bit 组成的信息是 A。
>
> 信号解释如下 : 
>
> 1. **HCLK（时钟信号）**
>
>     这是整个传输过程的时钟信号，用于同步其他信号的传输。
>
> 2. **HADDR[31:0]（地址信号）**
>
>     这是主模块发送的地址信号，用于指定从模块中的某个地址。
>
> 3. **Control（控制信号）**
>
>     主模块发送的控制信号，用于指示传输操作的类型（如读或写）。
>
> 4. **HWDATA[31:0]（数据信号）**
>
>     主模块发送的数据信号，在读数据操作中，这个信号没有数据，仅在写数据操作中使用。
>
> 5. **HREADY（准备好信号）**
>
>     从模块发送的信号，指示从模块是否已经准备好接收或发送数据。
>
> 6. **HRDATA[31:0]（数据信号）**
>
>     从模块发送的数据信号，在读数据操作中使用。
>
> 读/写的时候分别看 HRDATA / HWDATA
>
> 下面 Data(A) 代表 A 地址处读出的数据。

1. 主模块发出地址和控制 : A / Control
2. 从模块采样地址和控制。注意它其实每个周期都在采样，所以主模块发出地址和控制后的下一个时钟上升沿会立刻知道
3. 从模块根据控制信息，获取到数据，然后发出读数据
4. 主模块采样读数据，传输完成。

#### 要点说明

1. **在第一个时钟上升沿之后，主模块驱动 HADDR 和 Control 信号**

2. **在第二个时钟上升沿，从模块采样 HADDR 和 Control 信号**

3. **在第二个时钟上升沿之后**

    - 写传输 : 主模块驱动 HWDATA 信号
    - 读传输 : 从模块驱动 HRDATA 信号

4. **在第三个时钟上升沿**
    - 写传输 : 从模块采样 HWDATA 信号，完成传输
    - 读传输 : 主模块采样 HRDATA 信号，完成传输

### :dizzy: 场景 2 : 主模块发起传输时，从模块却未准备好

![time_2a](11总线与总线标准.assets/time_2a.png)

![time_2b](11总线与总线标准.assets/time_2b.png)

#### 要点说明

-   从模块可以在传输过程中插入等待周期，以便获得额外的时间

    如暂存写数据的缓冲已满、读数据未准备好等

-   在等待周期中，**主模块必须保持地址、控制和写数据等信号的稳定**

### :dizzy: 场景3 : 多个连续的传输

![time3](11总线与总线标准.assets/time3.png)  

#### 要点说明

##### 时间重叠（overlap）
- 不同传输的地址和数据在时间上存在重叠

- 充分利用地址总线和数据总线

  就是第二个时钟周期内，其实 HADDR Control 上面的信息没有必要保持为 A 传输的信息，因为从模块已经采样完了，所以直接改为 B 的。

  **重点是要观察 HREADY 是否被拉高了，如果拉高了那就可以传新的，否则就得保持。**

##### 等待周期
- 地址A和C的传输中没有等待周期
- 地址B的传输中有一个等待周期，该传输的数据阶段扩展了一个周期

##### 等待周期的副作用
- 因为地址B的传输中的等待周期，所以地址C的传输的地址阶段受其影响而扩展了一个周期

### :dizzy: 场景 4 : 大量连续数据的传输

**大量连续数据的传输** : 一次传输的数据量超过了数据总线的宽度

例如，CPU需要从内存中读出连续的16字节 (128位)的数据，但数据总线宽度为32位

#### 新的信号

`HTRANS[1:0]` : 定义传输中各周期的类型

![htrans](11总线与总线标准.assets/htrans.png)  

`HBURST[2:0]` : 定义了传输长度和地址变化方式

![hburst](11总线与总线标准.assets/hburst.png)  

不推荐使用 INCR，因为阻塞太久了，一般发固定长度的传输。

![time4](11总线与总线标准.assets/time4.png)  

#### T1-T7 时序说明

- **T1**: 传输开始，主模块发出第一个地址，驱动 HTRANS=NONSEQ，HBURST=INCR4

  - 驱动信号 HTRANS 设置为 NONSEQ，**表示这是一个新的传输序列的开始**。
  - HBURST 设置为 INCR4，表示这是一个包含 4 个数据传输的连续突发传输
  - 地址增加的步长在 HSIZE 处看，这里没有指明，但是是 4

- **T2**: 传输继续，主模块发出第二个地址，驱动 HTRANS=SEQ，保持 HBURST=INCR4

  - 驱动信号 HTRANS 设置为 SEQ，表示这是一个连续的传输序列。
  - HBURST 继续保持为 INCR4，表示仍在进行 4 个数据传输的连续突发传输。

- ...

- **T6**: 主模块发出的第四个地址已被从模块采样，无需再发出新的地址和控制信号，因此驱动 HTRANS=IDLE

  - 驱动信号 HTRANS 设置为 IDLE，表示传输进入空闲状态。

- **T7**: 传输完成

  - 驱动信号 HTRANS 设置为 IDLE，表明地址总线空闲

  - 所有信号恢复到初始状态，等待下一次传输的开始。

注意这张图中同时标明了写和读的情况。

注意 T3 时刻，HRDATA 和 HWDATA 的不同表现。

### :dizzy: 场景 5 : 希望先得到Burst传输中的某个特定数据

![time5](11总线与总线标准.assets/time5.png)  

注意，这里的回卷传输会把地址转回来。

想想 ics，就是先发关键字，然后把缓存块搞出来

#### 要点说明

##### 地址回卷的边界（假设数据宽度为4字节）
- **WRAP4**: 在16的整数倍的地址处回卷（4个数据宽度）
- **WRAP8**: 在32的整数倍的地址处回卷（8个数据宽度）
- **WRAP16**: 在64的整数倍的地址处回卷（16个数据宽度）

##### 传输地址变化示例
- **INCR4**: 0x38  0x3C  0x40  0x44
- **WRAP4**: 0x38  0x3C  0x30  0x34
- **INCR4**: 0x30  0x34  0x38  0x3C

### :dizzy: 场景 6 : 在Burst传输的过程中，主模块未准备好

![time6](11总线与总线标准.assets/time6.png)  

### :dizzy: 场景 7 : 需要传输的数据宽度比数据总线的宽度小

`HSIZE[2:0]` : 定义了传输数据的宽度

![time7](11总线与总线标准.assets/time7.png)  





___



# :scroll: 5.12 中断控制器和定时器

## :star2: 1. 中断和异常的来源

第一个带有异常处理的系统 : UNIVAC， 1951 年

算术运算溢出时 : **转向地址 0 执行两条修复指令，或者停机。可以通过修改地址 0 的内容来改变处理方式。**

后来 UNIVAC 也增加了对外部中断的处理。

**外部中断** : 输入输出需要中断现有程序的运行

第一个带有外部中断的系统 : DYSEAC，1954 年

有两个程序计数器（PC），根据外部输入输出设备（I/O）的信号，可以在这两个程序计数器之间进行切换， 这样它就可以交叉执行两端不同的程序。

### CPU 遇到的事件

1. 在程序运行时，系统外部、内部或现行程序本身出现需要特殊处理的 “事件”
2. CPU 立即强行中止现行程序的运行，改变机器的工作状态并启动相应的程序来处理这些 “事件”
3. 处理完成后，CPU 恢复原来的程序运行

### 事件的命名

![event_name](9.中断和异常.assets/event_name.png)

本课程中主要采用 : 外部中断 / 内部中断，统称为中断

### 中断向量表的结构

UNIVAC 对异常处理的方式 : 修改地址 0 的内容，这并不够用，因为随着异常的增多，需要处理的异常情况也会增多，而且需要根据异常情况的不同区执行不同的异常处理指令，这时候就需要中断向量表。

在 8086 中，存储器中保留两个专用区域 : 

-   中断向量表区 : 00000H~003FFH （地址最低的 1KB）
-   初始化程序区 : FFFF0H~FFFFFH （地址最高的 16B）

![address_graph](9.中断和异常.assets/address_graph.png)

可以看到，整个地址范围从 00000H 到 FFFFFH 共计 1MB，其中 : 

-   专用区（初始化程序区） : 占用了 FFFF0H 到 FFFFFH，CPU 复位后从地址 FFFF0H 取出第一条指令，通常是一条无条件转移指令， 转移到系统程序的入口处
-   通用区 : 占用了 00400H 到 FFFEFH，用来存储一般的程序指令和数据。**中断处理的程序储存在这个区域中**
-   专用区（中断向量表区） : 占用了 00000H 到 003FFH，存放了 256 个中断处理程序的入口地址（也称中断向量），每个入口地址占用 4B，即 1KB

## :star2: 2. 中断向量（Interrupt Vector）

![interrupt_vector](9.中断和异常.assets/interrupt_vector.png)

每个中断类型对应一个中断向量，其一共有 4 个字节 : 

-   前（低）两个字节 : 存放中断服务程序入口的偏移量（IP），低字节在前，高字节在后（小端法）
-   后（高）两个字节 : 存放中断服务程序入口的段地址（CS）

CPU 使用段加偏移来根据上述的逻辑地址产生物理地址（`CS<<4 + IP`），然后访问中断服务程序。`:` 不代表地址的分隔，只是为了区分段地址和偏移地址。

**中断服务程序** 在内存当中的存放顺序并没有要求，但是中断向量表中的 **中断向量** 的顺序是固定的。

对于 8086 的中断向量表 CPU 已经固定使用了前五个类型的中断。 那具体的功能我们后面会再介绍， 那之后的 27 个中断也是保留给后续的 CPU 使用的。 而除了前 32 个中断，之后的 224 个的中断则是交给使用 CPU 的用户自行定义。

### 中断向量表的发展

![8086-interrupt](9.中断和异常.assets/8086-interrupt.png)

8086 只有前 5 个类型的中断，但是保留了 32 个中断向量，后面的 27 个中断是保留给后续的 CPU 使用的。

![8086-to-core-2-interrupt](9.中断和异常.assets/8086-to-core-2-interrupt.png)

实模式下，可以认为个人计算机是一个非常快的 8086。因此当 CPU 复位之后，也会去 1MB 地址空间的最高的 16 个 Byte 的位置去取第一条指令。

这个地址会被南北桥芯片组引导到 BIOS 芯片。CPU 执行 BIOS 芯片当中的指令，对主板上的各个设备进行基本的配置。 **其中一项工作，就是在组成地址 0 的地方构建出中断向量表。同时准备好对应的中断服务程序**

IA-32 及以后，在保护模式中，段基址存储在描述符中，使用描述符表来索引。16 位的 CS 寄存器的寻址范围是 $2^{16} = 64 \text{KB}$，恰好能索引 8192 个 8B 的描述符，每个描述符对应一个段。

然而，描述符表的起始位置并不是 0，而是由 GDTR 寄存器指定的位置（在实模式中填写他的值）。因而，可以使用 `GDTR + CS` 来获取段描述符的地址，然后提取出段基址。

与实模式不同，中断向量表改称为了中断描述符表（IDT），它的起始地址也不再是 0，**而是由 IDTR 寄存器指定的**，IDT 中的每个描述符对应一个中断向量，总共有 256 个描述符。

IDT 中的每个描述符是 8B，其中包含了中断服务程序的段选择符（会放入 CS 寄存器）和偏移量（会放入 EIP 寄存器）。

所以，陷入中断时，CPU 将中断类型号乘以 8 再加上 IDTR 计存器中的内容，得到中断描述符的地址，然后获取中断描述符中的段选择符和偏移量。**这里的段选择符会进一步用于索引 GDT，获取段基址**。最后，CPU 将段基址和偏移量组合成实际物理地址，跳转到中断服务程序。

![interrupt_in_protect_mode](9.中断和异常.assets/interrupt_in_protect_mode.png)

##:star2: 4. 中断的处理过程

### 中断的检测

同时检测内部中断和外部中断。

![interrupt_detection](9.中断和异常.assets/interrupt_detection.png)

## :star2: 3. 中断处理过程

1. **关中断** : CPU 关闭中断响应，即 **不再接受其它外部中断请求（注意内部中断请求不受影响）**

2. **保存断点** : 将发生中断处的指令地址压入堆栈，以使中断处理完后能正确地返回。

    具体保存的可能是 : 

    - 发生中断的这条指令的地址
    - 发生中断的这条指令之后的一条指令的地址

    和这个中断具体的类型会有关系。

3. **识别中断源** : CPU 识别中断的来源，**确定中断类型号**，从而找到相应的中断服务程序的入口地址

4. **保护现场** : 在处理中断时，要将发生中断处的有关寄存器（中断服务程序中要使用的寄存器）以及标志寄存器的内容 **压入堆栈**，以便中断服务程序执行完毕后能恢复现场（也即弹栈）

5. **执行中断服务程序** : 转到中断服务程序入口开始执行，可在适当时刻重新开放中断，以便允许响应较高优先级的外部中断

6. **恢复现场并返回** : 把 “保护现场” 时压入堆栈的信息弹回原寄存器，然后执行中断返回指令，从而返回主程序继续运行

### 中断（使能）标志 (IF, Interrupt Flag)

上述过程中提到，在中断服务程序中可以重新开放中断，接下来讲这是怎么做到的。

先介绍一个标志位，IF

IF 控制对可屏蔽中断的响应 : 

-   若 `IF=1`，则 **允许** CPU 响应可屏蔽中断请求
-   若 `IF=0`，则 **不允许** CPU 响应可屏蔽中断请求

> 可屏蔽中断请求 : 可以通过软件屏蔽的中断请求，即通过修改 IF 标志位来控制 CPU 是否响应可屏蔽中断请求

可以用指令设置 IF 标志位 : 

-   `STI` : 把中断标志 IF 置 1
-   `CLI` : 把中断标志 IF 清 0

**IF 标志对非屏蔽中断和内部中断都是不起作用的。**

### 从中断服务程序中返回 : IRET 指令

-   该指令在中断服务程序结束时使用
-   通过从栈中弹出 3 个字，恢复之前保存的 IP、CS 和 FLAGS 寄存器值，使程序返回到中断前的运行状态

扩展 : 

-   `IRETD` : 用于 32 位操作系统中，恢复 EIP、CS 和 EFLAGS 寄存器
-   `IRETQ` : 用于 64 位操作系统中，恢复 RIP、CS 和 RFLAGS 寄存器

![interrupt_process](9.中断和异常.assets/interrupt_process.png)

## :star2: 4. 内部中断分类说明

![real_mode_interrupt](9.中断和异常.assets/real_mode_interrupt.png)

![inside_interrupt](9.中断和异常.assets/inside_interrupt.png)

### 类型 0 : 除法错误

-   产生条件 : 除数为 0 / 商溢出（除数为 0 可以看做是商溢出的特殊情况，其值为无穷大）

### 类型 4 : 溢出

-   执行 `INTO` 指令时，若溢出标志位 OF 为 1，则将引起类型为 4 的内部中断
-   执行 `INTO` 指令时，若溢出标志位 OF 为 0，则 `INTO` 指令执行空操作

`INTO` 指令通常安排在算术运算指令之后，以便在发生溢出时能及时处理指令

`INTO` 等同于指令 `INT 4`。

> 记忆 : INT Overflow

4 号中断和刚才介绍的 0 号中断，在引起中断的时机上是有区别的 : 虽然它们都在检查运算时出现的异常情况，但是 0 号中断是在错误的除法指令执行后，立刻发生的，而 4 号中断则是要在编程时，加入 `INTO` 指令进行 **主动的检查**。因为很多时候加法溢出并不需要处理。

### 类型 1 : 单步中断

**单步中断** : 当标志寄存器的 `TF` 位置 1 之后，CPU 便处于单步工作方式。在单步工作方式下，CPU 每执行完一条指令，就会自动产生一个类型 1 中断，进入类型 1 中断服务程序。（类似于现在的 Debug 单步调试）

类型 1 中断服务程序 : 一般用于显示 CPU 内部各寄存器的内容和一些其它信息，以便进行调试和发现错误

`TF` : Trap Flag，陷阱标志位，用于控制单步工作方式。

### 类型 3 : 断点中断

**断点中断** : 当执行 `INT 3` 指令时，CPU 会产生一个类型 3 中断，进入类型 3 中断服务程序。

不同于其他的 `INT` 加中断类型号的指令都是一个两字节的指令，断点中断是一个例外，**`INT 3` 指令是一条单字节长的指令**。

#### 断点中断的使用

断点中断是一种常见的调试技术，它允许程序员在程序中设置一个或多个停止点（即断点），程序运行到这些点时会暂停执行，这样开发者可以检查程序状态，如变量值、内存内容和寄存器状态等。断点中断的基本流程可以分为以下几个步骤 : 

##### 设置断点

-   **指令替换** : 在需要设置断点的位置，用断点中断指令 `INT 3` 替换原有的用户程序指令。
-   **保存原指令** : 在替换之前，需保存被替换的原指令以便之后恢复执行。

##### 发生断点

-   **执行中断** : 当程序执行到断点位置时，会执行 `INT 3` 指令，触发断点中断服务程序。
-   **状态显示** : 通常，断点中断服务程序会显示 CPU 各寄存器的值和其他重要的调试信息。

##### 恢复执行

-   **指令恢复** : 在中断服务程序返回前，需要恢复原有的用户程序指令。
-   **程序计数器调整** : 将程序计数器（IP）的值减 1，确保从断点位置继续执行。

### 内部中断的特点

#### 中断类型号

-   **内部中断的类型号** 由 CPU 内部产生，这意味着它是 **自动生成** 的。
-   不同于内部中断，**外部中断** 则需要 **从外设读取** 中断类型号。

#### 屏蔽方式

-   大部分内部中断（除单步中断外） **不能通过软件方法来禁止（屏蔽）**。
-   **单步中断** 可以通过软件操作 TF 标志（置 1 或清 0）来允许或禁止。

#### 优先级

-   除单步中断外，所有 **内部中断的优先级都比外部中断高**。

## :star2: 5. 基于中断的功能调用

### INT 指令

格式 :  `INT n`

-   x86 系统提供的直接调用中断服务程序的手段。
-   `n` 为 0~255 中的某一个数，对应中断类型码。

操作 : 

1. 将 `FLAGS` 寄存器的内容压栈。
2. 清除中断标志 `IF` 和单步标志 `TF`。
3. 将 `CS` 和 `IP` 寄存器的内容压栈。
4. 根据中断类型码查找中断向量表，取得对应中断服务程序的入口地址，并将入口地址分别装入 `CS` 和 `IP` 寄存器。

### BIOS 中断

BIOS 中断是一种特殊的中断，它是由 BIOS 提供的一组中断服务程序，用于提供一些基本的硬件控制和系统服务。

BIOS 中断具有多个中断类型号。每个中断类型号对应一个特定的中断服务程序。

<img src="./9.中断和异常.assets/CleanShot 2024-06-12 at 01.54.25@2x.png" alt="CleanShot 2024-06-12 at 01.54.25@2x" style="zoom:50%;" />

我们不妨来看一个例子，这个表是 BIOS 中断的一个片段， 那想使用 BOIS 中断，首先就得查找 BIOS 中断的手册，这个手册，一般会提供这样一个表格，列出了 BIOS 这些功能模块所在用的中断号， 比如说 10H，就是用于在显示器上进行显示的一个中断服务程序， 而 1AH，则是设置系统时钟的一个中断服务程序。

我们以 1AH 为例，那如果我们想要改变现在的系统时钟，当然我们可以去分析时钟管理芯片的功能，通过查找它的手册，来分析如何去改变系统时钟的设置，这可能要花很多个步骤。 那 BIOS 的设计者，就帮我们封装好了这个功能， 我们只要这样写代码就可以了。

因为我们通过这个表可以看到，如果要设置时钟，我们需要提供一个功能号为 1， 因为 1AH 这个中断里头，其实有多种功能， 我们可能想读出当前时钟的值，也可能要改变当前时钟的值， 这个中断服务程序怎么识别呢，它就要求你在 AH 寄存器当中放入一个数， 那么在中断服务程序的开始，会先检查 AH 寄存器，如果里面是 0，那它就按照读时钟的操作，运行后续的代码，如果 AH 里面的值是 1，它就按照设置时钟的操作，执行后续的代码， 那现在我们要设置时钟，所以在 AH 里面先放上 1， 然后我们查这张表，知道我们要设置的时间是放在这几个寄存器当中，CH 放在要设置的小时数，CL 放要上要设的分钟数，DH 是秒，DL 是百分之一秒， 而 CL 和 CH 组成的寄存器是 CX，DL 和 DH 组成的寄存器是 DX， 所以我们直接可以通过对 CX 和 DX 赋值，来设置这个时间.

那么现在为了简单，我们就设成 0 点 0 分 0 秒， 这些参数准备好以后，我们最后写 INT 1AH， 接下来就像是之前介绍过，发生中断的时候一样， CPU 会去中断向量表当中，找到 1AH 对应的中断向量，然后转移到对应的中断服务程序开始执行，而这段中断服务程序就是位于 BIOS 所在的存储区域， 那在这个中断服务程序当中，就会去操作管理系统时钟的芯片或者部件，完成时钟的更改， 然后再返回到这个主程序当中，继续执行下面的代码。

### DOS 中断

DOS 是早期的一种操作系统，它占用了一个中断类型号，21H， 和 BIOS 占据了多个中断类型号不同，**DOS 中断只有这一个类型号**， 但它的功能非常的丰富，常用的文件管理、 存储管理等很复杂的功能，都可以种这个中断服务程序来解决

格式 : `INT 21H`

功能 : 

-   包含最常用的功能程序，分别实现文件管理、存储管理、作业管理和设备管理等功能。
-   共用 21H 号中断入口，**通过传参数的方式设置功能号**，以选择执行不同功能模块的代码。

特点 : 

-   DOS 中断功能比 BIOS 中断更齐全、完整。
-   进一步屏蔽了设备的物理特性及其接口特性。

我们也来看一个例子，如果我们想在屏幕上输出一个 `$` 字符，那我们可以查找 DOS 中断所提供的表格， DOS 中断都是 21H，所以这个表里面只需要列出功能号， 那么发现，6 号功能是在进行输入输出的操作，所以我们现在 AH 寄存器当中，存入 6，然后我们进一步发现， 如果我们想输出一个字符，就在 DL 寄存器当中，放入我们想显示的这个字符，而如果我们想通过键盘输入这个字符，则只需要在 DL 寄存器当中，存入 FF， 而最后输入的字符，会放在 AL 寄存器当中。

那我们现在还是来看输出， 所以我们在 DL 寄存器当中，存上这个字符， 然后调用 INT 21H， 这样 CPU 就会转向 21H 号中断所对应的中断服务程序， 在这个服务程序当中，首先会检查 AH 里面的值，确定功能号， 然后就进入到这个功能对应的程序代码段， 再根据 DL 寄存器的内容，判断出这是一次输出，那这个服务程序接下来就会对显示器进行操作， 让对应的字符显示在屏幕的合适的位置， 那这些繁琐的工作，都不需要用户来关心了， 只要简单的调用这个 DOS 中断就可以了。

<img src="./9.中断和异常.assets/CleanShot 2024-06-12 at 01.51.44@2x.png" alt="CleanShot 2024-06-12 at 01.51.44@2x" style="zoom:50%;" />

前提这些操作都已经由其它的程序员帮你写好，并且封装起来。你只需要调用这些中断，就可以实现相应的功能。

##  :star2: 线下课内容

### :dizzy: MIPS CPU的异常处理

- 在EPC中保存出现异常的指令的地址
  - EPC : Exception Program Conter，异常程序计数器
  - 需要将当前保存的指令地址-4
- 清空流水线中之后的指令
- 记录产生异常的原因 `Cause`
- 把控制权转交给操作系统的特定地址。转移到特定地址执行下一条指令



### :dizzy: 如何确定外部中断优先级
#### :dash: 软件查询
  - 硬件上简单 : 将所有外部中断请求信号相 "或".
> - 带优先级的查询程序 : 在中断服务程序的开头，需安排一段查询程序, 其先后顺序体现不同设备的中断优先级
> - 一般来说，总是先查询速度较快或是实时性较高的设备

![alt text](\9.中断和异常.assets\软件查询.png)

#### :dash: 硬件中断优先级编码电路（菊花链）
菊花链优先级排队电路 : 一种优先级管理的简单硬件方案
- 在每个设备接口设置一个简单的逻辑电路，根据优先级顺序来传递或截留CPU发出的中断响应信号，以实现响应中断的顺序

![alt text](\9.中断和异常.assets\菊花链逻辑.png)
#### :dash: 可编程中断控制器 PIC
- 现代PC中多采用这种方式
  - 管理和控制CPU的外部中断请求
  - 实现中断优先级的判决
  - 为CPU提供中断类型码
  - 选择屏蔽设备的中断请求
> 高级可编程中断控制器 APIC

<div style="display: flex; gap: 10px;">
  <img src="9.中断和异常.assets/image-1.png" alt="alt text" style="flex: 1; width: 100px;"/>
  <img src="9.中断和异常.assets/image-2.png" alt="alt text" style="flex: 1; width: 100px;"/>
</div>


### :dizzy: 定时/计数
#### :dash: 可编程计数器/定时器
- 软硬件相结合的定时计数方法，采用专用的定时电路，其定时值通过软件进行控制
- 特点  : 功能灵活，使用方便
- ljl : 早期就是一颗独立的芯片
> 定时器 Intel 8253,  内部结构不细讲

![alt text](\9.中断和异常.assets\定时器内部结构.png)
#### :dash: 定时器的内部主要部件
计数器0、计数器1、计数器2
- 3个计数器/定时器通道
- 3个通道的操作是完全独立的

信号解释
- CLK : 时钟输入信号，作为计数脉冲，可以是非周期性脉冲，也可以是频率精确的周期性脉冲
- GATE : 门控输入信号，对计数过程进行控制，具体作用视工作方式而定
- OUT : 计数输出信号，“计数到零/定时时间到”输出，输出信号形式视工作方式而定
####  :dash: 方式2 分频器

- 输出波形 : 每输入N个CLK脉冲，输出宽度为1个CLK周期的负脉冲
- 触发方式 : 软件启动，自动重复，周期性输出固定频率的脉冲, 又称为Rate Generator
- 主要用途 : 脉冲速率发生器，类似“Divide-by-N”Counter. $Count(N) = Input(Hz) / Frequency of Output$

##### 用于DRAM的定时刷新
![alt text](\9.中断和异常.assets\DRAM定时刷新.png)
####  :dash: 方式3 方波发生器
- 输出波形 : 对称方波或基本对称的矩形波