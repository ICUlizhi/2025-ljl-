[TOC]


<style>
  img {
    width: 80%; /* 统一宽度（百分比或固定值如600px） */
    height: auto; /* 保持比例 */
    display: block; /* 居中显示 */
    margin: 0 auto;
  }
</style>

# :scroll: 5.28 复习
1/3 期中前, 2/3期中后

以下mooc部分省略
## 🌟01-课程概述-20250217
### :dizzy: 四个计算机及其特点
- ENIAC : 世界上第一台电子计算机
- EDVAC : 存储程序计算机(即冯·诺依曼结构)
  - feature : 存储程序、二进制、顺序执行
  - conponents : 输入设备、输出设备、存储器、运算器、控制器
- EDSAC : 第一台具有存储程序的通用计算机 
- UNIVAC : 第一台商用计算机
- 大型, 超级, 小型, 微型

## 🌟02-控制器的基本原理-20250317
## 🌟03-输入输出接口实例-20250409
具体接口不需要掌握
### :dizzy: 并行与串行比较
- 差分信号
- 可编程接口不要求

## 🌟04-总线与总线标准-20250428

### :dizzy: 总线
- 概念, 主模块, 从模块, 译码器, 仲裁器
### :dizzy: 总线标准
- 总线标准产生的途径, 标准的内容
### :dizzy: 时序图
不同场景
## 🌟05-中断控制器和定时器-20250512
### :dizzy: MIPS CPU 的异常处理
### :dizzy: 外部中断优先级
- 菊花链电路
- 早期和现在的中断控制器结构
### :dizzy: 定时器
- 不会考的很精确, 都是给定需求由我们选择方式
- 中断控制器和定时器在IBM PC/AT中的连接结构

## 🌟06-流水线优化技术-20250521
- x86第一代流水线 (图)
- 转移指令的影响
- 延迟转移技术
- 转移预测技术 (重点)
  - 优缺点
- 两位历史信息
- BTB 动作机制
- 返回地址栈

## 🌟07-计算机系统先进技术(1)-20250526
- 片上总线的缺点 & 片上网络出现
- DDR4 如何工作, 为什么不太合适继续加倍, 以及使用 Bank Grouping 技术
- MSI 中断机制 (为什么, 之前的机制有什么问题)
## 🌟08-计算机系统先进技术(2)-20250604


# :scroll: 4.23 HBM 讲座

## :star2: HBM 技术
面向人工智能的芯片

### :dizzy: Motivation
DDR 的速度每 3-5 年翻一倍

- 3DS DDR 替代了传统的 DDR 设计
- Wide IO 替代 LPDDR
- **HBM** 替代了 GDDR 

### :dizzy: Introduction of HBM

- 变化 : 
  - 可堆叠更多芯片（容量+）
  - 可分离更多通道（性能+）
  - 可集成更多电池（容量+）
  - 可降低电源电压（功率效率+）
- 制约摆放 HBM3 数量的因素是 logic die 的长边长度, 这里 H100 一边放了 3 个

### :dizzy: Future products
- 行业趋势1 : 集成更多(边缘)HBM堆叠
- 行业趋势2 : 异质三维集成
- 行业趋势3 : Processing in Memory (PIM)
___





# :scroll: 4.28 & 4.30 总线及总线标准

## :star2: 1. 总线
在多于两个模块(设备或子系统)之间传送信息的公共通路
- 组成
  - 传输信息的电路
  - 管理信息传输的协议
- 分类
  - **片上总线** : 中央处理器芯片内部的总线
  - **内总线** : 系统总线或版级总线, 各插件板之间信息传输的通路
  - **外总线** : 通信总线, 计算机系统之间/计算机系统与其他系统

### :dizzy: 总线模块

#### :dash: 总线主模块 (Bus Master)

-   具有**总线控制**能力，在获得总线控制权之后**能启动总线传输**（读数据或写数据）
-   示例 : CPU、DMA 控制器

#### :dash: 总线从模块 (Bus Slave)

-   能够对总线传输**作出响应**（接收写数据、返回读数据、返回“错误”响应等），但本身不具备总线控制能力
-   示例 : 存储器

### :dizzy: 辅助元件

**总线译码器(Bus Decoder)**  : 根据当前控制总线的主模块提供的地址，选择作为本次总线传输目标的从模块

**总线仲裁器(Bus Arbiter)**  : 在总线上有**多个主模块同时请求**使用总线时，决定由哪个主模块获得总线控制权, 让总线得到合理、高效地使用

![bus_sys](11总线与总线标准.assets/bus_sys.png)

地址总线 : 主模块 → 总线 → 从模块
数据/控制总线 : 主模块 ↔ 总线 ↔ 从模块

![bus_circuit](11总线与总线标准.assets/bus_circuit.png)

![bus_80386](11总线与总线标准.assets/bus_80386.png)

![bus_complex_sys](11总线与总线标准.assets/bus_complex_sys.png)

- 真实系统中的很多总线模块包含主模块和从模块的双重功能及接口
- 有比较慢的设备，使用总线桥接器来连接。

## :star2: 2. 常见总线协议

**事实标准** : 计算机系统厂家所采用的一种总线，由于其性能优越，逐渐形成一种被业界广泛支持和承认的事实总线标准

**国际标准** : 在国际标准组织或机构主持下开发和制定的总线标准，公布后由厂家和用户使用

### :dizzy: 总线标准的内容

1. **机械特性** : 规定模块插件的机械尺寸，总线插头、插座的规格及位置等

2. **电气特性** : 规定总线信号的逻辑电平、噪声容限及负载能力等

3. **功能特性** : 给出各总线信号的名称及功能定义

4. **规程特性** : 对各总线信号的动作过程及时序关系进行说明

- 举例 : ISA、PCI、PCI Express、EISA、AGP、USB

- 现在最常用的是 **PCIe**

> PPT里此处有 ISA, EISA, PCA, AGP 的历史, 感觉不会考

### :dizzy: PCI Express

#### :dash: 全新的基础架构

-   **串行方式**传输数据，依靠高频率获得高性能
-   **全双工运作模式**，同时进行数据发送和接收
-   点对点连接结构，而非传统的共享结构

#### :dash: PCIe 总线物理层采用差分信号传输

- 优点 : 抗干扰能力强, 能有效抑制电磁干扰, 时序定位准确
- 缺点 : 在电路板上，差分信号一定要走两根等长、等宽、紧密靠近且在同一层面的线，布线难度高

#### :dash: PCIe链路的带宽和编码方式
- PCIe使用GT(Gigatransfer)计算链路的峰值带宽
$$单条链路的峰值带宽 = 总线频率×数据位宽×2 (单位 : GT/s）$$
- PCIe链路可以由多个 **通道（Lane）** 组成, 目前支持宽度 为 1, 2, 4, 8, 12, 16 和 32 的链路
## :star2: 3. 总线协议实例

### :dizzy: 场景 1 : 读写 1 个数据

![time_1a](11总线与总线标准.assets/time_1a.png)

![time_1b](11总线与总线标准.assets/time_1b.png)  


> 这张图中的灰色六边形代表此时信号不稳定。
>
> A 代表此时信号已经稳定，32bit 组成的信息是 A。
>
> 信号解释如下 : 
>
> 1. **HCLK（时钟信号）**
>
>     这是整个传输过程的时钟信号，用于同步其他信号的传输。
>
> 2. **HADDR[31:0]（地址信号）**
>
>     这是主模块发送的地址信号，用于指定从模块中的某个地址。
>
> 3. **Control（控制信号）**
>
>     主模块发送的控制信号，用于指示传输操作的类型（如读或写）。
>
> 4. **HWDATA[31:0]（数据信号）**
>
>     主模块发送的数据信号，在读数据操作中，这个信号没有数据，仅在写数据操作中使用。
>
> 5. **HREADY（准备好信号）**
>
>     从模块发送的信号，指示从模块是否已经准备好接收或发送数据。
>
> 6. **HRDATA[31:0]（数据信号）**
>
>     从模块发送的数据信号，在读数据操作中使用。
>
> 读/写的时候分别看 HRDATA / HWDATA
>
> 下面 Data(A) 代表 A 地址处读出的数据。

1. 主模块发出地址和控制 : A / Control
2. 从模块采样地址和控制。注意它其实每个周期都在采样，所以主模块发出地址和控制后的下一个时钟上升沿会立刻知道
3. 从模块根据控制信息，获取到数据，然后发出读数据
4. 主模块采样读数据，传输完成。

#### 要点说明

1. **在第一个时钟上升沿之后，主模块驱动 HADDR 和 Control 信号**

2. **在第二个时钟上升沿，从模块采样 HADDR 和 Control 信号**

3. **在第二个时钟上升沿之后**

    - 写传输 : 主模块驱动 HWDATA 信号
    - 读传输 : 从模块驱动 HRDATA 信号

4. **在第三个时钟上升沿**
    - 写传输 : 从模块采样 HWDATA 信号，完成传输
    - 读传输 : 主模块采样 HRDATA 信号，完成传输

### :dizzy: 场景 2 : 主模块发起传输时，从模块却未准备好

![time_2a](11总线与总线标准.assets/time_2a.png)

![time_2b](11总线与总线标准.assets/time_2b.png)

#### 要点说明

-   从模块可以在传输过程中插入等待周期，以便获得额外的时间

    如暂存写数据的缓冲已满、读数据未准备好等

-   在等待周期中，**主模块必须保持地址、控制和写数据等信号的稳定**

### :dizzy: 场景3 : 多个连续的传输

![time3](11总线与总线标准.assets/time3.png)  

#### 要点说明

##### 时间重叠（overlap）
- 不同传输的地址和数据在时间上存在重叠

- 充分利用地址总线和数据总线

  就是第二个时钟周期内，其实 HADDR Control 上面的信息没有必要保持为 A 传输的信息，因为从模块已经采样完了，所以直接改为 B 的。

  **重点是要观察 HREADY 是否被拉高了，如果拉高了那就可以传新的，否则就得保持。**

##### 等待周期
- 地址A和C的传输中没有等待周期
- 地址B的传输中有一个等待周期，该传输的数据阶段扩展了一个周期

##### 等待周期的副作用
- 因为地址B的传输中的等待周期，所以地址C的传输的地址阶段受其影响而扩展了一个周期

### :dizzy: 场景 4 : 大量连续数据的传输

**大量连续数据的传输** : 一次传输的数据量超过了数据总线的宽度

例如，CPU需要从内存中读出连续的16字节 (128位)的数据，但数据总线宽度为32位

#### 新的信号

`HTRANS[1:0]` : 定义传输中各周期的类型

![htrans](11总线与总线标准.assets/htrans.png)  

`HBURST[2:0]` : 定义了传输长度和地址变化方式

![hburst](11总线与总线标准.assets/hburst.png)  

不推荐使用 INCR，因为阻塞太久了，一般发固定长度的传输。

![time4](11总线与总线标准.assets/time4.png)  

#### T1-T7 时序说明

- **T1**: 传输开始，主模块发出第一个地址，驱动 HTRANS=NONSEQ，HBURST=INCR4

  - 驱动信号 HTRANS 设置为 NONSEQ，**表示这是一个新的传输序列的开始**。
  - HBURST 设置为 INCR4，表示这是一个包含 4 个数据传输的连续突发传输
  - 地址增加的步长在 HSIZE 处看，这里没有指明，但是是 4

- **T2**: 传输继续，主模块发出第二个地址，驱动 HTRANS=SEQ，保持 HBURST=INCR4

  - 驱动信号 HTRANS 设置为 SEQ，表示这是一个连续的传输序列。
  - HBURST 继续保持为 INCR4，表示仍在进行 4 个数据传输的连续突发传输。

- ...

- **T6**: 主模块发出的第四个地址已被从模块采样，无需再发出新的地址和控制信号，因此驱动 HTRANS=IDLE

  - 驱动信号 HTRANS 设置为 IDLE，表示传输进入空闲状态。

- **T7**: 传输完成

  - 驱动信号 HTRANS 设置为 IDLE，表明地址总线空闲

  - 所有信号恢复到初始状态，等待下一次传输的开始。

注意这张图中同时标明了写和读的情况。

注意 T3 时刻，HRDATA 和 HWDATA 的不同表现。

### :dizzy: 场景 5 : 希望先得到Burst传输中的某个特定数据

![time5](11总线与总线标准.assets/time5.png)  

注意，这里的回卷传输会把地址转回来。

想想 ics，就是先发关键字，然后把缓存块搞出来

#### 要点说明

##### 地址回卷的边界（假设数据宽度为4字节）
- **WRAP4**: 在16的整数倍的地址处回卷（4个数据宽度）
- **WRAP8**: 在32的整数倍的地址处回卷（8个数据宽度）
- **WRAP16**: 在64的整数倍的地址处回卷（16个数据宽度）

##### 传输地址变化示例
- **INCR4**: 0x38  0x3C  0x40  0x44
- **WRAP4**: 0x38  0x3C  0x30  0x34
- **INCR4**: 0x30  0x34  0x38  0x3C

### :dizzy: 场景 6 : 在Burst传输的过程中，主模块未准备好

![time6](11总线与总线标准.assets/time6.png)  

### :dizzy: 场景 7 : 需要传输的数据宽度比数据总线的宽度小

`HSIZE[2:0]` : 定义了传输数据的宽度

![time7](11总线与总线标准.assets/time7.png)  





___



# :scroll: 5.12 & 5.14 中断控制器和定时器

## :star2: 1. 中断和异常的来源

第一个带有异常处理的系统 : UNIVAC， 1951 年

算术运算溢出时 : **转向地址 0 执行两条修复指令，或者停机。可以通过修改地址 0 的内容来改变处理方式。**

后来 UNIVAC 也增加了对外部中断的处理。

**外部中断** : 输入输出需要中断现有程序的运行

第一个带有外部中断的系统 : DYSEAC，1954 年

有两个程序计数器（PC），根据外部输入输出设备（I/O）的信号，可以在这两个程序计数器之间进行切换， 这样它就可以交叉执行两端不同的程序。

### CPU 遇到的事件

1. 在程序运行时，系统外部、内部或现行程序本身出现需要特殊处理的 “事件”
2. CPU 立即强行中止现行程序的运行，改变机器的工作状态并启动相应的程序来处理这些 “事件”
3. 处理完成后，CPU 恢复原来的程序运行

### 事件的命名

![event_name](9.中断和异常.assets/event_name.png)

本课程中主要采用 : 外部中断 / 内部中断，统称为中断

### 中断向量表的结构

UNIVAC 对异常处理的方式 : 修改地址 0 的内容，这并不够用，因为随着异常的增多，需要处理的异常情况也会增多，而且需要根据异常情况的不同区执行不同的异常处理指令，这时候就需要中断向量表。

在 8086 中，存储器中保留两个专用区域 : 

-   中断向量表区 : 00000H~003FFH （地址最低的 1KB）
-   初始化程序区 : FFFF0H~FFFFFH （地址最高的 16B）

![address_graph](9.中断和异常.assets/address_graph.png)

可以看到，整个地址范围从 00000H 到 FFFFFH 共计 1MB，其中 : 

-   专用区（初始化程序区） : 占用了 FFFF0H 到 FFFFFH，CPU 复位后从地址 FFFF0H 取出第一条指令，通常是一条无条件转移指令， 转移到系统程序的入口处
-   通用区 : 占用了 00400H 到 FFFEFH，用来存储一般的程序指令和数据。**中断处理的程序储存在这个区域中**
-   专用区（中断向量表区） : 占用了 00000H 到 003FFH，存放了 256 个中断处理程序的入口地址（也称中断向量），每个入口地址占用 4B，即 1KB

## :star2: 2. 中断向量（Interrupt Vector）

![interrupt_vector](9.中断和异常.assets/interrupt_vector.png)

每个中断类型对应一个中断向量，其一共有 4 个字节 : 

-   前（低）两个字节 : 存放中断服务程序入口的偏移量（IP），低字节在前，高字节在后（小端法）
-   后（高）两个字节 : 存放中断服务程序入口的段地址（CS）

CPU 使用段加偏移来根据上述的逻辑地址产生物理地址（`CS<<4 + IP`），然后访问中断服务程序。`:` 不代表地址的分隔，只是为了区分段地址和偏移地址。

**中断服务程序** 在内存当中的存放顺序并没有要求，但是中断向量表中的 **中断向量** 的顺序是固定的。

对于 8086 的中断向量表 CPU 已经固定使用了前五个类型的中断。 那具体的功能我们后面会再介绍， 那之后的 27 个中断也是保留给后续的 CPU 使用的。 而除了前 32 个中断，之后的 224 个的中断则是交给使用 CPU 的用户自行定义。

### 中断向量表的发展

![8086-interrupt](9.中断和异常.assets/8086-interrupt.png)

8086 只有前 5 个类型的中断，但是保留了 32 个中断向量，后面的 27 个中断是保留给后续的 CPU 使用的。

![8086-to-core-2-interrupt](9.中断和异常.assets/8086-to-core-2-interrupt.png)

实模式下，可以认为个人计算机是一个非常快的 8086。因此当 CPU 复位之后，也会去 1MB 地址空间的最高的 16 个 Byte 的位置去取第一条指令。

这个地址会被南北桥芯片组引导到 BIOS 芯片。CPU 执行 BIOS 芯片当中的指令，对主板上的各个设备进行基本的配置。 **其中一项工作，就是在组成地址 0 的地方构建出中断向量表。同时准备好对应的中断服务程序**

IA-32 及以后，在保护模式中，段基址存储在描述符中，使用描述符表来索引。16 位的 CS 寄存器的寻址范围是 $2^{16} = 64 \text{KB}$，恰好能索引 8192 个 8B 的描述符，每个描述符对应一个段。

然而，描述符表的起始位置并不是 0，而是由 GDTR 寄存器指定的位置（在实模式中填写他的值）。因而，可以使用 `GDTR + CS` 来获取段描述符的地址，然后提取出段基址。

与实模式不同，中断向量表改称为了中断描述符表（IDT），它的起始地址也不再是 0，**而是由 IDTR 寄存器指定的**，IDT 中的每个描述符对应一个中断向量，总共有 256 个描述符。

IDT 中的每个描述符是 8B，其中包含了中断服务程序的段选择符（会放入 CS 寄存器）和偏移量（会放入 EIP 寄存器）。

所以，陷入中断时，CPU 将中断类型号乘以 8 再加上 IDTR 计存器中的内容，得到中断描述符的地址，然后获取中断描述符中的段选择符和偏移量。**这里的段选择符会进一步用于索引 GDT，获取段基址**。最后，CPU 将段基址和偏移量组合成实际物理地址，跳转到中断服务程序。

![interrupt_in_protect_mode](9.中断和异常.assets/interrupt_in_protect_mode.png)

##:star2: 4. 中断的处理过程

### 中断的检测

同时检测内部中断和外部中断。

![interrupt_detection](9.中断和异常.assets/interrupt_detection.png)

## :star2: 3. 中断处理过程

1. **关中断** : CPU 关闭中断响应，即 **不再接受其它外部中断请求（注意内部中断请求不受影响）**

2. **保存断点** : 将发生中断处的指令地址压入堆栈，以使中断处理完后能正确地返回。

    具体保存的可能是 : 

    - 发生中断的这条指令的地址
    - 发生中断的这条指令之后的一条指令的地址

    和这个中断具体的类型会有关系。

3. **识别中断源** : CPU 识别中断的来源，**确定中断类型号**，从而找到相应的中断服务程序的入口地址

4. **保护现场** : 在处理中断时，要将发生中断处的有关寄存器（中断服务程序中要使用的寄存器）以及标志寄存器的内容 **压入堆栈**，以便中断服务程序执行完毕后能恢复现场（也即弹栈）

5. **执行中断服务程序** : 转到中断服务程序入口开始执行，可在适当时刻重新开放中断，以便允许响应较高优先级的外部中断

6. **恢复现场并返回** : 把 “保护现场” 时压入堆栈的信息弹回原寄存器，然后执行中断返回指令，从而返回主程序继续运行

### 中断（使能）标志 (IF, Interrupt Flag)

上述过程中提到，在中断服务程序中可以重新开放中断，接下来讲这是怎么做到的。

先介绍一个标志位，IF

IF 控制对可屏蔽中断的响应 : 

-   若 `IF=1`，则 **允许** CPU 响应可屏蔽中断请求
-   若 `IF=0`，则 **不允许** CPU 响应可屏蔽中断请求

> 可屏蔽中断请求 : 可以通过软件屏蔽的中断请求，即通过修改 IF 标志位来控制 CPU 是否响应可屏蔽中断请求

可以用指令设置 IF 标志位 : 

-   `STI` : 把中断标志 IF 置 1
-   `CLI` : 把中断标志 IF 清 0

**IF 标志对非屏蔽中断和内部中断都是不起作用的。**

### 从中断服务程序中返回 : IRET 指令

-   该指令在中断服务程序结束时使用
-   通过从栈中弹出 3 个字，恢复之前保存的 IP、CS 和 FLAGS 寄存器值，使程序返回到中断前的运行状态

扩展 : 

-   `IRETD` : 用于 32 位操作系统中，恢复 EIP、CS 和 EFLAGS 寄存器
-   `IRETQ` : 用于 64 位操作系统中，恢复 RIP、CS 和 RFLAGS 寄存器

![interrupt_process](9.中断和异常.assets/interrupt_process.png)

## :star2: 4. 内部中断分类说明

![real_mode_interrupt](9.中断和异常.assets/real_mode_interrupt.png)

![inside_interrupt](9.中断和异常.assets/inside_interrupt.png)

### 类型 0 : 除法错误

-   产生条件 : 除数为 0 / 商溢出（除数为 0 可以看做是商溢出的特殊情况，其值为无穷大）

### 类型 4 : 溢出

-   执行 `INTO` 指令时，若溢出标志位 OF 为 1，则将引起类型为 4 的内部中断
-   执行 `INTO` 指令时，若溢出标志位 OF 为 0，则 `INTO` 指令执行空操作

`INTO` 指令通常安排在算术运算指令之后，以便在发生溢出时能及时处理指令

`INTO` 等同于指令 `INT 4`。

> 记忆 : INT Overflow

4 号中断和刚才介绍的 0 号中断，在引起中断的时机上是有区别的 : 虽然它们都在检查运算时出现的异常情况，但是 0 号中断是在错误的除法指令执行后，立刻发生的，而 4 号中断则是要在编程时，加入 `INTO` 指令进行 **主动的检查**。因为很多时候加法溢出并不需要处理。

### 类型 1 : 单步中断

**单步中断** : 当标志寄存器的 `TF` 位置 1 之后，CPU 便处于单步工作方式。在单步工作方式下，CPU 每执行完一条指令，就会自动产生一个类型 1 中断，进入类型 1 中断服务程序。（类似于现在的 Debug 单步调试）

类型 1 中断服务程序 : 一般用于显示 CPU 内部各寄存器的内容和一些其它信息，以便进行调试和发现错误

`TF` : Trap Flag，陷阱标志位，用于控制单步工作方式。

### 类型 3 : 断点中断

**断点中断** : 当执行 `INT 3` 指令时，CPU 会产生一个类型 3 中断，进入类型 3 中断服务程序。

不同于其他的 `INT` 加中断类型号的指令都是一个两字节的指令，断点中断是一个例外，**`INT 3` 指令是一条单字节长的指令**。

#### 断点中断的使用

断点中断是一种常见的调试技术，它允许程序员在程序中设置一个或多个停止点（即断点），程序运行到这些点时会暂停执行，这样开发者可以检查程序状态，如变量值、内存内容和寄存器状态等。断点中断的基本流程可以分为以下几个步骤 : 

##### 设置断点

-   **指令替换** : 在需要设置断点的位置，用断点中断指令 `INT 3` 替换原有的用户程序指令。
-   **保存原指令** : 在替换之前，需保存被替换的原指令以便之后恢复执行。

##### 发生断点

-   **执行中断** : 当程序执行到断点位置时，会执行 `INT 3` 指令，触发断点中断服务程序。
-   **状态显示** : 通常，断点中断服务程序会显示 CPU 各寄存器的值和其他重要的调试信息。

##### 恢复执行

-   **指令恢复** : 在中断服务程序返回前，需要恢复原有的用户程序指令。
-   **程序计数器调整** : 将程序计数器（IP）的值减 1，确保从断点位置继续执行。

### 内部中断的特点

#### 中断类型号

-   **内部中断的类型号** 由 CPU 内部产生，这意味着它是 **自动生成** 的。
-   不同于内部中断，**外部中断** 则需要 **从外设读取** 中断类型号。

#### 屏蔽方式

-   大部分内部中断（除单步中断外） **不能通过软件方法来禁止（屏蔽）**。
-   **单步中断** 可以通过软件操作 TF 标志（置 1 或清 0）来允许或禁止。

#### 优先级

-   除单步中断外，所有 **内部中断的优先级都比外部中断高**。

## :star2: 5. 基于中断的功能调用

### INT 指令

格式 :  `INT n`

-   x86 系统提供的直接调用中断服务程序的手段。
-   `n` 为 0~255 中的某一个数，对应中断类型码。

操作 : 

1. 将 `FLAGS` 寄存器的内容压栈。
2. 清除中断标志 `IF` 和单步标志 `TF`。
3. 将 `CS` 和 `IP` 寄存器的内容压栈。
4. 根据中断类型码查找中断向量表，取得对应中断服务程序的入口地址，并将入口地址分别装入 `CS` 和 `IP` 寄存器。

### BIOS 中断

BIOS 中断是一种特殊的中断，它是由 BIOS 提供的一组中断服务程序，用于提供一些基本的硬件控制和系统服务。

BIOS 中断具有多个中断类型号。每个中断类型号对应一个特定的中断服务程序。

<img src="./9.中断和异常.assets/CleanShot 2024-06-12 at 01.54.25@2x.png" alt="CleanShot 2024-06-12 at 01.54.25@2x" style="zoom:50%;" />

我们不妨来看一个例子，这个表是 BIOS 中断的一个片段， 那想使用 BOIS 中断，首先就得查找 BIOS 中断的手册，这个手册，一般会提供这样一个表格，列出了 BIOS 这些功能模块所在用的中断号， 比如说 10H，就是用于在显示器上进行显示的一个中断服务程序， 而 1AH，则是设置系统时钟的一个中断服务程序。

我们以 1AH 为例，那如果我们想要改变现在的系统时钟，当然我们可以去分析时钟管理芯片的功能，通过查找它的手册，来分析如何去改变系统时钟的设置，这可能要花很多个步骤。 那 BIOS 的设计者，就帮我们封装好了这个功能， 我们只要这样写代码就可以了。

因为我们通过这个表可以看到，如果要设置时钟，我们需要提供一个功能号为 1， 因为 1AH 这个中断里头，其实有多种功能， 我们可能想读出当前时钟的值，也可能要改变当前时钟的值， 这个中断服务程序怎么识别呢，它就要求你在 AH 寄存器当中放入一个数， 那么在中断服务程序的开始，会先检查 AH 寄存器，如果里面是 0，那它就按照读时钟的操作，运行后续的代码，如果 AH 里面的值是 1，它就按照设置时钟的操作，执行后续的代码， 那现在我们要设置时钟，所以在 AH 里面先放上 1， 然后我们查这张表，知道我们要设置的时间是放在这几个寄存器当中，CH 放在要设置的小时数，CL 放要上要设的分钟数，DH 是秒，DL 是百分之一秒， 而 CL 和 CH 组成的寄存器是 CX，DL 和 DH 组成的寄存器是 DX， 所以我们直接可以通过对 CX 和 DX 赋值，来设置这个时间.

那么现在为了简单，我们就设成 0 点 0 分 0 秒， 这些参数准备好以后，我们最后写 INT 1AH， 接下来就像是之前介绍过，发生中断的时候一样， CPU 会去中断向量表当中，找到 1AH 对应的中断向量，然后转移到对应的中断服务程序开始执行，而这段中断服务程序就是位于 BIOS 所在的存储区域， 那在这个中断服务程序当中，就会去操作管理系统时钟的芯片或者部件，完成时钟的更改， 然后再返回到这个主程序当中，继续执行下面的代码。

### DOS 中断

DOS 是早期的一种操作系统，它占用了一个中断类型号，21H， 和 BIOS 占据了多个中断类型号不同，**DOS 中断只有这一个类型号**， 但它的功能非常的丰富，常用的文件管理、 存储管理等很复杂的功能，都可以种这个中断服务程序来解决

格式 : `INT 21H`

功能 : 

-   包含最常用的功能程序，分别实现文件管理、存储管理、作业管理和设备管理等功能。
-   共用 21H 号中断入口，**通过传参数的方式设置功能号**，以选择执行不同功能模块的代码。

特点 : 

-   DOS 中断功能比 BIOS 中断更齐全、完整。
-   进一步屏蔽了设备的物理特性及其接口特性。

我们也来看一个例子，如果我们想在屏幕上输出一个 `$` 字符，那我们可以查找 DOS 中断所提供的表格， DOS 中断都是 21H，所以这个表里面只需要列出功能号， 那么发现，6 号功能是在进行输入输出的操作，所以我们现在 AH 寄存器当中，存入 6，然后我们进一步发现， 如果我们想输出一个字符，就在 DL 寄存器当中，放入我们想显示的这个字符，而如果我们想通过键盘输入这个字符，则只需要在 DL 寄存器当中，存入 FF， 而最后输入的字符，会放在 AL 寄存器当中。

那我们现在还是来看输出， 所以我们在 DL 寄存器当中，存上这个字符， 然后调用 INT 21H， 这样 CPU 就会转向 21H 号中断所对应的中断服务程序， 在这个服务程序当中，首先会检查 AH 里面的值，确定功能号， 然后就进入到这个功能对应的程序代码段， 再根据 DL 寄存器的内容，判断出这是一次输出，那这个服务程序接下来就会对显示器进行操作， 让对应的字符显示在屏幕的合适的位置， 那这些繁琐的工作，都不需要用户来关心了， 只要简单的调用这个 DOS 中断就可以了。

<img src="./9.中断和异常.assets/CleanShot 2024-06-12 at 01.51.44@2x.png" alt="CleanShot 2024-06-12 at 01.51.44@2x" style="zoom:50%;" />

前提这些操作都已经由其它的程序员帮你写好，并且封装起来。你只需要调用这些中断，就可以实现相应的功能。

##  :star2: 线下课内容

### :dizzy: MIPS CPU的异常处理

- 在EPC中保存出现异常的指令的地址
  - EPC : Exception Program Conter，异常程序计数器
  - 需要将当前保存的指令地址-4
- 清空流水线中之后的指令
- 记录产生异常的原因 `Cause`
- 把控制权转交给操作系统的特定地址。转移到特定地址执行下一条指令



### :dizzy: 如何确定外部中断优先级
#### :dash: 软件查询
  - 硬件上简单 : 将所有外部中断请求信号相 "或".
> - 带优先级的查询程序 : 在中断服务程序的开头，需安排一段查询程序, 其先后顺序体现不同设备的中断优先级
> - 一般来说，总是先查询速度较快或是实时性较高的设备

![alt text](\9.中断和异常.assets\软件查询.png)

#### :dash: 硬件中断优先级编码电路（菊花链）
菊花链优先级排队电路 : 一种优先级管理的简单硬件方案
- 在每个设备接口设置一个简单的逻辑电路，根据优先级顺序来传递或截留CPU发出的中断响应信号，以实现响应中断的顺序

![alt text](\9.中断和异常.assets\菊花链逻辑.png)
#### :dash: 可编程中断控制器 PIC
- 现代PC中多采用这种方式
  - 管理和控制CPU的外部中断请求
  - 实现中断优先级的判决
  - 为CPU提供中断类型码
  - 选择屏蔽设备的中断请求
> 高级可编程中断控制器 APIC

<div style="display: flex; gap: 10px;">
  <img src="9.中断和异常.assets/image-1.png" alt="alt text" style="flex: 1; width: 100px;"/>
  <img src="9.中断和异常.assets/image-2.png" alt="alt text" style="flex: 1; width: 100px;"/>
</div>


### :dizzy: 定时/计数
#### :dash: 可编程计数器/定时器
- 软硬件相结合的定时计数方法，采用专用的定时电路，其定时值通过软件进行控制
- 特点  : 功能灵活，使用方便
- ljl : 早期就是一颗独立的芯片
> 定时器 Intel 8253,  内部结构不细讲

![alt text](\9.中断和异常.assets\定时器内部结构.png)
#### :dash: 定时器的内部主要部件
计数器0、计数器1、计数器2
- 3个计数器/定时器通道
- 3个通道的操作是完全独立的

信号解释
- CLK : 时钟输入信号，作为计数脉冲，可以是非周期性脉冲，也可以是频率精确的周期性脉冲
- GATE : 门控输入信号，对计数过程进行控制，具体作用视工作方式而定
- OUT : 计数输出信号，“计数到零/定时时间到”输出，输出信号形式视工作方式而定
####  :dash: 方式2 分频器

- 输出波形 : 每输入N个CLK脉冲，输出宽度为1个CLK周期的负脉冲
- 触发方式 : 软件启动，自动重复，周期性输出固定频率的脉冲, 又称为Rate Generator
- 主要用途 : 脉冲速率发生器，类似“Divide-by-N”Counter. $Count(N) = Input(Hz) / Frequency of Output$

##### 用于DRAM的定时刷新
![alt text](\9.中断和异常.assets\DRAM定时刷新.png)
- IBM PC XT/AT中，8253通道1的专用功能
- 刷新频率 : 若每2ms需刷新128次，则刷新频率为64KHz
- 对于计数通道1, 方式2, 计数初值 $N=18$, 
  - $ 输入频率 1.19318MHz / 输出频率 64KHz = 18 $

####  :dash: 方式3 方波发生器
- 输出波形 : 对称方波或基本对称的矩形波
- 触发方式 : 软件启动，自动重复，周期性输出固定频率的的方波, 又称为Square Wave Generator
- 主要用途 : 产生系统的时钟, 扬声器发声控制

##### 产生系统的时钟
- IBM PC XT/AT中，8253通道0的专用功能
- 为系统软件产生基本计时单位 (定时中断)
- 对于计数通道0, 方式3, 计数初值 $N = 最大值65536$,
  - 输出方波频率为 $1.19318MHz / 65536 = 18.2Hz$
  - 定时中断间隔 : $54.945ms$

### :dizzy: 系统中的中断和定时
![alt text](\9.中断和异常.assets\中断控制器和定时器.png)

<div style="display: flex; gap: 10px;">
  <img src="9.中断和异常.assets\南北桥1.png" alt="alt text" style="flex: 1; width: 100px;"/>
  <img src="9.中断和异常.assets/南北桥2.png" alt="alt text" style="flex: 1; width: 100px;"/>
</div>
<div style="display: flex; gap: 10px;">
  <img src="9.中断和异常.assets/南北桥3.png" alt="alt text" style="flex: 1; width: 100px;"/>
  <img src="9.中断和异常.assets/系统芯片.png" alt="alt text" style="flex: 1; width: 100px;"/>
</div>




# :scroll: 5.21 流水线优化技术

## 流水线的基本原理

![pipeline_sketch](7.流水线处理器.assets/pipeline_sketch.png)

采用流水线：

-   **流水线填满之后**，可以做到每 1 分钟上一道菜：性能提升到原先的 4 倍
-   单独一道菜仍然需要 4 分钟

### MIPS 的主要步骤

![MIPS_steps](7.流水线处理器.assets/MIPS_steps.png)

对 MIPS 处理器亦进行阶段划分：

![MIPS_stages](7.流水线处理器.assets/MIPS_stages.png)

虽然分组了，但是所有的信号都需要在每个阶段中保持稳定。为了充分利用硬件，我们添加寄存器：

![pipeline_regs](7.流水线处理器.assets/pipeline_regs.png)

### 流水线处理器性能分析

![pipeline_perf_analysis](7.流水线处理器.assets/pipeline_perf_analysis.png)

时钟周期：流水线处理器的时钟周期是流水线中 **最慢的阶段的时钟周期**

这是没带上流水线寄存器的，带上之后：

![pipeline_perf_with_reg](7.流水线处理器.assets/pipeline_perf_with_reg.png)

### 总结

流水线中的各个处理部件可 **并行工作**，从而可使 **整个程序** 的执行时间缩短

流水线并 **不会缩短单条指令的执行时间** （甚至由于流水线寄存器的存在，会增加时间） ，而是 **提高了指令的吞吐率**

## 流水线的优化

### 流水线的调整

不平衡的流水线：每个阶段花费时间不相等的流水线，对单一条指令执行时间和整个处理器的吞吐率都不好。

因此，需要尽可能的平衡各个阶段的时间。为此可能要更细地切分阶段，使之变为平衡的流水线。

![super_pipeline](7.流水线处理器.assets/super_pipeline.png)

**超级流水线技术 (Super Pipelining)**：将流水线细分为更多的阶段，增加流水线的深度提升时钟频率，从而 **提高指令吞吐率**

但是流水线的级数不是越多越好，因为有流水线寄存器的存在，所以更深的级数会导致单条指令的延迟越来越大，流水线寄存器延迟所占比例也越来越大，填满一条流水线所需的指令也会增加。

x86 被 RISC 追赶，所以做出了改进：在流水线内部用硬件把复杂的 x86 指令划分为更细的 RISC 指令，从而既可以使用先进的 RISC 技术（流水线等），也可以保证对原先的 x86 程序的兼容。

2004，Pemtium 4 (Prescott) 达到了 31 级（最高）。

现在我们已经很难简单的通过增加流水线的深度来获得性能上的提升了。

## 超标量流水线

**超标量（Superscalar）**：具有两条或两条以上 **并行工作** 的流水线结构称为 **超标量结构**

-   亦称为 “超标量流水线” 或直接称为 “超标量”。
-   与之相对，之前的流水线则称为 “标量流水线”

使用超标量结构的处理器称为 **超标量处理器**

几条流水线就称为几发射。

### Pentium 的超标量流水线（第一款超标量 x86 CPU）

双发射，5 级流水线

-   两条流水线：“U 流水” 和 “V 流水”
-   共用取值、译码阶段
-   每条流水线都拥有自己的地址生成逻辑、ALU 及数据 Cache 接口
-   在一个时钟周期内，可以 **同时发送两条指令**

![pentium](7.流水线处理器.assets/pentium.png)

CDC6000：通常认为是最早采用超标量技术的计算机，有 10 个并行功能部件，不过没有流水线。by 西摩・克雷

### Core i7 的超标量流水线

由于长度变长，需要先进行指令的识别。

**超标量（Superscalar）**

-   具有两条或两条以上并行工作的流水线结构称为超标量结构亦称为 “超标量流水线” 或直接称为 “超标量”

    -   与之相对，之前的流水线则称为 “标量流水线”
    -   使用超标量结构的处理器称为超标量处理器

-   标量流水线和超标量流水线

    -   单周期 → 标量流水线：**时间并行性** 的优化，主要是对现有硬件的切分。
    -   标量流水线 → 超标量流水线：**空间并行性** 的优化，需成倍增加硬件资源

### 超标量流水线与多核 CPU

现代的多核 CPU 通常是在一个 CPU 芯片中集成了多个超标量处理器核

![core_i7](7.流水线处理器.assets/core_i7.png)

这是 4 核的处理器。

## 流水线冒险

冒险：阻止下一条指令在下一个时钟周期开始执行的情况

-   **结构冒险**：所需的硬件部件正在为之前的指令工作。
-   **数据冒险**：需要等待之前的指令完成数据的读写。
-   **控制冒险**：需要根据之前指令的结果决定下一步的行为。

### 结构冒险

![struct_hazard](7.流水线处理器.assets/struct_hazard.png)

问题来源：如果指令和数据放在同一个存储器中，则不能同时读存储器

解决方案 1：流水线停顿（stall），产生空泡（bubble），这是安全且简便的方法，但是会严重影响效率。

解决方案 2：指令和数据放在不同的存储器中（更本质的解决问题）

![struct_hazard_2](7.流水线处理器.assets/struct_hazard_2.png)

问题来源：读寄存器和写寄存器同时发生

解决方案：前半个时钟周期写，后半个时钟周期读，并且设置独立的读写口（错开）

### 数据冒险

![data_hazard](7.流水线处理器.assets/data_hazard.png)

这段指令的代码第一条减法指令， 它的运算结果会放到 t0 寄存器当中，而下一条指令需要将 t0 寄存器作为加法运算的一个原操作数， 从这段代码的功能看来加法指令所用的 t0 寄存器的内容，显然应该是减法指令的运算结果。

但是在流水线处理器上， 加法指令开始执行时，这条减法指令的运算结果可能还没有写到 t0 寄存器当中去， 我们结合图示来进行说明。 减法指令需要到第五个周期也就写回这个周期才会将运算结果写到 t0 寄存器当中去， 而加法指令在第三个周期也就它自己的译码这个阶段就需要读出 t0 寄存器， 那从这里就可以看出，这条加法指令需要用前一条指定的运算结果， 但是在这个时刻这个运算结果还没有写回到寄存器当中去， 这就产生了数据冒险，如果不做任何处理任由加法指令去读取寄存器堆，那此时得到的 t0 寄存器的值肯定不是由前面这条减法指令运算得出的，这样就会导致这个程序运行结果的错误。

问题来源：一条指令（add）需要使用之前指令（sub）的运算结果，但是结果还没有写回

临时解决方案：流水线停顿（stall），产生 2 个空泡（bubble）

<img src="./7.流水线处理器.assets/CleanShot 2024-06-11 at 23.25.00@2x.png" alt="CleanShot 2024-06-11 at 23.25.00@2x" style="zoom:50%;" />

既然结果还没有产生，那我就等到你结果产生， 根据这个流水线的结构我们需要让流水线停顿两个周期，这样在加法指令读寄存器堆的时候，减法指令已经将运算的结果写回到了 t0 寄存器当中去， 所以加法指令读到的是正确的数值。

### 控制冒险

![control_hazard](7.流水线处理器.assets/control_hazard.png)

这段代码第一条指令是条件分支指令，后续跟了若干的指令.

要注意的是在第二个时钟周期，处理器就应该去取下一条指令了，但这个时候实际上并不知道是否真的会发生分支， 这条分支指令一直要到执行阶段结束，才能知道分支的条件是否成立，也就在 600ps 这个时候，而处理器希望在 200ps 的时候就去取下一条指令，这里就产生了控制冒险，因为这个区指定的动作如何进行应该由上一条地指令的运行结果来决定， 而上一条指令的运行结果至少要到两个时钟周期之后才能产生，那在还没有确定是否发生分支的情况下如何进行下一次的取值呢？

问题来源：尚未确定是否发生分支，如何进行下一次取指？

临时解决方案：流水线停顿(stall)，产生 2 个**空泡(bubble)**

<img src="./7.流水线处理器.assets/CleanShot 2024-06-11 at 23.33.10@2x.png" alt="CleanShot 2024-06-11 at 23.33.10@2x" style="zoom:50%;" />

需要插入两个空泡，那么在执行阶段结束之后，我们就知道要从哪个地方开始取新的指令了。

## 数据冒险的处理

![data_hazard_solution_nop](7.流水线处理器.assets/data_hazard_solution_nop.png)

软件解决方案：插入一条 `nop` 指令，也即什么都不做，等待数据准备好。

但是这样并不能很好适配流水线架构更新的情况。当流水线级数增加，等待的周期数也需要同时增加。

硬件解决方案 1：执行流水线停顿（stall），产生空泡（bubble）。

检测数据冒险的方法：对比在 **译码阶段获得的需要读的寄存器的编号** 与后面各个阶段正在执行的指令是否要写某个寄存器，以及 **要写哪个寄存器**。

时间角度重新看这条指令，在 `sub` 指令执行完 ALU 计算后，其实已经可以开始执行 `add` 指令了，只是由于数据还没有写回，所以不能执行。

因此，我们得到：

硬件解决方案 2：**数据前递（Forwarding） / 旁路（Bypass）**

思想：把执行阶段的结果直接提前传递给需要的阶段，而不是等待写回阶段。

<img src="./7.流水线处理器.assets/CleanShot 2024-06-11 at 23.34.53@2x.png" alt="CleanShot 2024-06-11 at 23.34.53@2x" style="zoom:50%;" />

在 600ps 的时候，ALU 的输出结果已经是 t0 的值了， 那在 600ps 的这个时钟上沿过去之后，t0 的这个值会被保存到执行和访存之间的这个流水线寄存器当中去。 我们如果把它传递给 ALU 的输入，就可以正确的完成后面这条加法运算了。

![forwarding](7.流水线处理器.assets/forwarding.png)

看一看硬件上怎么来修改。 这条减法指令在执行完运算以后，运算结果已经保存到了这个寄存器当中。 那现在，这条减法指令进入到访存阶段， t0 的值将会通过这个阶段传到下一级流水线寄存器。 而与此同时，加法指令正在执行阶段，它需要将 t0 寄存器的值送到 ALU 的一个输入端。 那显然，它的上一个阶段从寄存器堆当中读到的值，肯定不是最新的。

现在这个最新的值在访存阶段的连线上。 所以我们从硬件连线上可以把这个信号引回来，从新引到 ALU 的输入端。

**相当于绕过了寄存器堆，直接从执行阶段传递给需要的阶段。**

<img src="./7.流水线处理器.assets/CleanShot 2024-06-11 at 23.36.51@2x.png" alt="CleanShot 2024-06-11 at 23.36.51@2x" style="zoom:50%;" />

那我们进一步来看，其实不仅仅在这个点可以建立旁路，我们在下一个流水级也可以建立旁路。 那这条旁路在什么情况下会用上呢？我们还是结合一个例子来看。

这个例子前两条指令和刚才的那个例子是一样的， 在此基础上我们又写出了第三条指令， 这是一个与操作，那么它其中的一个原操作数也是 t0，那我们结合实践来看， 对于这条与操作指令，它真的要开始运算的时候，是在 800 ps 之后。那在这个时候，前面这条减法指令已经完成了访存阶段，所以 t0 寄存器的最新值，现在是放在访存阶段和写回阶段之间的流水线寄存器当中的， 那我们就需要用到刚才的结构图当中紫色的旁路的线， 用来将 t0 的内容传递到 ALU 到输入端，从而让这条与运算指令及时的运行。

### Load-Use 数据冒险

<img src="./7.流水线处理器.assets/CleanShot 2024-06-11 at 23.38.23@2x.png" alt="CleanShot 2024-06-11 at 23.38.23@2x" style="zoom:50%;" />

对于这一条 load 的指令，我们来看要保存到 t1 寄存器的值，究竟是什么时候才得到的，对于刚才的运算指令，需要写回寄存器的值，是在执行阶段，也就是通过 ALU 运算而得。 但是对于 load 的指令，用 ALU 是计算要访存的地址， 而要写回寄存器堆堆数，是在访存阶段的结束才会得到， 所以是在 1400ps 这个地方，我们才会得到 t1 寄存器的值。

而对于下面这一条或运算指令，我们最晚也得在 1200ps 这个地方， 得到 t1 这个寄存器的值，从而让 ALU 可以进行正确的运算。 因此，这就要求我们将 1400 ps 这个地方得到的数，传递到之前 1200 ps 这个时刻。

**那时光倒流的事情我们是做不到的。 所以我们只能让信号沿着时间轴向前传递，而绝不可能向后传递。**

因此，无论我们怎么修改电路，也无法构造出这样一条前递的通路。**我们只能让这条或运算指令多等一个周期**，这样它就可以在 1400ps 之后才需要这个 t1 寄存器的值。 而此时，load 的已经完成了从数据存储器当中取出数的操作， 这就可以通过刚才我们已经建立的第二组旁路通道，也就是用紫色的连线表达的这个旁路通道，将 t1 寄存器的内容传送到 ALU 的输入端口。 那当然，既然我们要让或运算指令延后一个周期，

<img src="./7.流水线处理器.assets/CleanShot 2024-06-11 at 23.39.58@2x.png" alt="CleanShot 2024-06-11 at 23.39.58@2x" style="zoom:50%;" />

定义：一条指令需要使用之前指令的访存结果（Load-Use Harzard） 。

此时，**数据前递 (Forwarding) 也无法解决**

这是因为 Load 必须在访存结束后才能得到结果，所以我们无法跨越时间提前传递数据。

因而，我们回退到之前的解决方法：流水线停顿（stall）+ 数据前递

这个解决方案没有让流水线获得最高的指令吞吐率，但是保证指令执行正确才是我们的首要目标。

## 控制冒险的处理

![control_hazard_improve](7.流水线处理器.assets/control_hazard_improve.png)

转移指令：改变指令流向，破坏流水模式

转移指令经常带来控制冒险，造成性能损失。因此，我们需要尽量减少转移指令的影响。

$$
\text{Pipeline stall cycles from branches} = \text{Branch Frequency} \times \text{Branch Penalty}
$$

当执行了转移指令，并确实发生转移时，产生如下的开销，称为 “转移开销”

1. 将按顺序预取的指令废除（即 “排空流水线”）
2. 从转移目标地址重新取指令

转移开销的构成：

1. “要不要转移？”：转移条件判定引起的开销
2. “转移到哪里？”：生成目标地址引起的开销

### 转移指令的分类

![transfer_inst_classification](7.流水线处理器.assets/transfer_inst_classification.png)

### 无条件转移

#### 直接转移

```asm
j target
```

![jr_target](7.流水线处理器.assets/jr_target.png)

对这条 `j` 指令来说，它所需要的转移目标地址在取指阶段就可以获得， 流水线不用停顿。

#### 间接转移

```asm
jr $rs
```

![jr_rs](7.流水线处理器.assets/jr_rs.png)

在取指阶段得到指令编码之后，并不能获得转移的目标地址， 因此取指部件至少要等待一个周期。

那当这条 JR 指令进入到译码阶段后，指令编码当中的 rs 域就会送到寄存器堆，然后得到对应的寄存器的内容， 那如果我们在这里把 busA 这个信号连接到 PC 的更新部件，那在 JR 这条指令的译码阶段结束的时候，转移的目标地址就可以送到 PC 寄存器的输入端了。

当下一个时钟上升沿来临的时候，这个地址就可以存到 PC 寄存器当中去， 然后在下一个时钟周期，送到指令存储器，**因此对于这条指令来说，因为我们在译码阶段才能获得转移目标地址，所以流水线需要停顿一个周期**。

### 条件转移

```asm
beq $rs, $rt, imm16
```

条件转移指令是一条 I 型指令，这条指令目标地址的计算方法是这样的，首先比较 rs 和 rt 所指向的寄存器的内容，如果它们相等，它们目标地址是在指令编码当中的 16 位立即数，进行符号扩展，然后乘以 4， 再加上当前 PC 的内容，再加 4， 而如果这两个寄存器的比较结果是不相等，那新的 PC 的值就只是当前 PC 值加 4， 那不管寄存器比较的结果是否相等，那这个新的 PC 的值都只跟当前的 PC 值和指令编码的内容相关，而这两项内容在取指阶段都是可以确定的。

所以这么看来，目标地址的生成不会造成流水线的停顿， 而问题在于，是否要转移，这个条件的判断， 我们还是结合结构图来看一看。

因为要判定转移是否成立，需要比较两个寄存器的内容， 而寄存器的内容，我们只能在译码阶段才能获得， 这样与刚才的间接转移类似，我们也得让流水线停顿一个周期，才可以获得这两个寄存器的内容。

但是与刚才间接指令不同的是，即使到译码阶段的结束，我们依然不能知道转移的条件是否成立， **因为我们还需要到执行阶段，将 ALU 来对这两个数进行比较，从而得到比较的结果**。 所以在这个结构下，我们需要让流水线 **停顿两个周期**，才能知道转移条件的判定结果.

其实要等到执行阶段结束，无非是要对两个 32 位数进行比较， **而比较两个数相等是一个非常简单的功能，不需要用到 ALU 这么复杂的部件**， 那我们就可以在译码阶段进行一些小的改造。 我们在寄存器堆的输出，busA 和 busB 这两个信号给它连接一个额外的比较电路， 这个电路是很简单的，速度也很快，不至于影响整个译码阶段的时间。

那我们把比较的结果再送到 PC 的更新部件，那这样在译码阶段结束的时候，我们就可以将下一条指令的地址送到 PC 寄存器了。 那经过这样的改动，条件转移指令也只需要让流水线 **停顿一个周期**， 就可以让指令正确地执行了。

![beq](7.流水线处理器.assets/beq.png)

比较指令较为简单，不需要用到 ALU，直接在 busA busB **连接一个额外的比较电路**，这个电路是很简单的，速度也很快，不至于影响整个译码阶段的时间。

![beq_2](7.流水线处理器.assets/beq_2.png)

### 控制冒险的影响

<img src="7.流水线处理器.assets/control_hazard_affect.png" alt="control_hazard_affect" style="zoom:50%;" />

-   无条件直接转移：`j Target`，流水线无停顿
-   无条件间接转移：`jr rs`，流水线停顿 1 个周期
-   条件转移：`beq rs，rt，imm16`，流水线停顿 1 个周期

### 延迟转移技术

通过上面的分析，我们发现，不同的转移指令带来的控制冒险是不一样的， 经过我们的改进之后，无条件的直接转移可以让流水线不停顿的。 而无条件的间接转移以及条件转移都不得不让流水线停顿一个周期， 才能消除控制冒险的影响。

但是如果我们还想进一步地消除这个影响，不让流水线停顿，是否可以做到呢？

那我们就来介绍一个简单的方法，就是延迟转移技术.

<img src="./7.流水线处理器.assets/CleanShot 2024-06-11 at 23.49.53@2x.png" alt="CleanShot 2024-06-11 at 23.49.53@2x" style="zoom:50%;" />

我们结合这张代码来进行分析，这里有一条条件转移指令， 在它之前依次是减法、加法和异或指令， 那按照通常的规则，这些指令依次进入流水线执行，当执行到这条 beq 指令的时候， 如果 t1、t2 两个寄存器的内容相同，就会跳到 Next 所指向的地方， 在 beq 进入流水线之后，必须还需要再等一个周期，才能知道转移条件是否满足， 那流水线必须停顿一个周期，那我们现在就是想办法把这个浪费的周期重新利用起来。

既然我们从硬件上现在无法解决这个问题，那我们不妨就修改这指令行为的定义，**我们就规定，它之后的那条指令是一定会被执行的，如果是这样，流水线中就不会出现被浪费的那个周期了**。

但是我们还要注意，这样的修改不应该改变程序本来想要达到的结果， 所以我们就需要修改一下这段代码，我们要在这个 beq 指令之后填上一条一定会被执行的指令， 那我们只能往上走，但是之前的这条减法指令和加法指令，它们的运算结果正好是 beq 指令所要比较的这两个寄存器， 所以这条加法指令和减法指令必须在 beq 指令之前执行。

而我们再往上看，这条异或指令与我们的判定条件没有关系， **现在我们就把这条异或指令挪到 beq 指令之后**，因为我们现在已经修改了转移指令的定义，那我们在流水线的硬件结构上，就可以确定地将 beq 之后的这条指令进入流水线， 而当这条异或指令完成取指进入译码阶段的时候， 这条 beq 指令的条件判断也已经完成。 如果条件成立，这时候就可以从 Next 所指向的这个地方开始取下一条指令了， 否则也可以顺序地取下一条指令， 但不论是哪一种情况，流水线都不会发生停顿。

![delayed_transfer](7.流水线处理器.assets/delayed_transfer.png)


# :scroll: 5.24 & 6.2 计算机系统先进技术

## 片上互连结构的发展

系统芯片(Sytem-on-a-Chip， SoC) 将计算机或其他电子系统集成单一芯片的集成电路

## 新的中断机制

### MSI 中断机制

Message Signaled Interrupt (消息信号中断)

当设备向一个特殊地址写入**数据**时，这个操作会触发一个中断，称为 MSI 中断。

![MSI](12.计算机系统先进技术.assets/MSI.png)

**MSI**和**MSI-X**都是通过写特殊地址触发中断，而不是通过物理引脚。

#### 支持情况

**PCI 总线**：

-   必须支持传统的 INTx 引脚中断。
-   MSI 机制是可选的。

**PCIe 总线**：

-   必须支持 MSI/MSI-X 机制。
-   可以不支持传统的 INTx 引脚中断。

#### MSI 机制的特点

##### 优点

1. **解决多个设备共享中断信号的问题**

    - **传统 INTx 引脚**：多个设备共享同一个中断信号，操作系统需要调用多个中断处理函数，效率低。
    - **MSI 机制**：每个设备都有独立的中断信号，减少了中断处理的复杂性，提高了效率。

2. **解决每个功能设备只支持一个中断的问题**

    - **传统方法**：中断服务程序需要查询设备来确定发生的事件，效率低。
    - **MSI 机制**：一个设备可以支持多个中断，为不同的用途分配不同的中断，提高了处理效率。

3. **数据完整性**
    - **传统中断**：可能存在数据写入未完成就触发中断的情况，导致数据不一致。
    - **MSI 机制**：保证中断信号的写操作不会越过数据写操作，中断服务程序可以确信所有数据已经到达内存，确保数据完整性。

##### 缺点

-   **占用总线带宽**：
    -   使用 MSI 时，产生中断的写操作会占用总线带宽，可能影响总线的性能。

### 总结

MSI 机制通过独立的中断信号和多中断支持，提高了中断处理的效率和数据完整性，但也存在占用总线带宽的问题。

希望这些解释对你理解 MSI 机制的特点有所帮助。如果有进一步的问题，请随时提问！

